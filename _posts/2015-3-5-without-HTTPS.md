---
layout: post
title:  "在不使用 HTTPS 的情况下，如何保证用户登录时提交密码已经加密?"
date:   2015-3-5
categories: [Security]
---
今天在群里有个小伙伴的网站被各位大牛吐槽了，槽点之一就是：注册时用户密码是用明文传输给服务器的。具体什么危害我竟然不知道，不怕，咱有谷歌！知乎中早有讨论：在不使用HTTPS的情况下，如何保证用户登录时提交密码已经加密？

> [http://www.zhihu.com/question/20060155](http://www.zhihu.com/question/20060155)


结合各位大牛的回答以及查找的资料，读书笔记如下：

1、密码提交以前，通过不可逆的JavaScript代码加密。因为对于任何摘要式的加密算法，都可以通过类似MD5字典的方式直接查表获知弱密码，所以MD5要混入salt来增加制作字典的时间。但是解密只是时间成本，所以这里的重要前提是对安全性要求不高。

如何验证密码呢？一个可行的方法是，客户端提交 md5(password) 密码（如上所述，此方法只是简单保护了密码，是可能被查表获取密码的）。服务端数据库通md5(salt+md5(password)) 的规则存储密码，该 salt 仅存储在服务端，且在每次存储密码时都随机生成。这样即使被拖库，制作字典的成本也非常高。密码被 md5() 提交到服务端之后，可通过 md5(salt + form['password']) 与数据库密码比对。此方法可以在避免明文存储密码的前提下，实现密码加密提交与验证。

2、问：客户端如果使用的是混入随机盐值md5加密的方法（比如qq网页登陆，用的盐值是每次的验证码），这种情况下，数据库里的密码是怎样存储的呢？、
答：一种可行的方法是，浏览器端：传输密码=可逆加密（hash（密码+存储盐），随机码盐）。服务器端：可逆加密的解密（浏览器请求密码，随即码盐），把结果和数据库中的存储密码相比较，得到结果。每个用户的salt都要记录下来，用额外的存储换安全性。

3、本地控件，如ActiveX。

4、屏幕键盘，用户的输入值，每个键盘都是重新初始化过的，每个值输入，只有当前用户的Session知道，用完就删掉，下次重新随机生成。

5、硬件加密，如银行的密保（U盾）

**精彩回答：**

1、@黄辉鹏

加密的本质是对原有内容的混淆，目的是提高从表面结果反推达到目的的成本。

在网页提交（其实所有的通信都有这个问题）密码这个问题上，需要有几个维度来保证安全，首先是切面的安全性，对于一次提交首先保护的是密码本身，从最早的Base64到MD5或是SHA都可以做到这一点，但是Base64是可逆的，对于密码本身的保护是很弱的，哈希算法解决了这个问题，将不同长度的数据转换成统一长度的大数字，而理论上这个数字对应无穷多解，但限于密码的输入有限制，其实是可逆的，所以从1次混淆的MD5变成了3次混淆的SHA，但是随着现代计算机技术的进步，逆运算的成本不断降低，人们不得已要使用更大的数字来提高这个难度，但是为了向成本和发展妥协，人们不得已使用统一的算法。

在CS时代由于很难侵入到CS两端，所以相对的双方使用的算法是保密的，破解难度相对比较大，BS由于为了保证开放性，特别是js本身就是明文算法，所以其实只能说防君子不妨小人，所以就有了安全控件，控件的唯一目的是用2进制代码来隐藏加密的算法，不知道算法，也就很难破解原文。


第二维度就是时间，如果密码一样加密结果也会一样，那么在不使用原文的情况下，可以使用加密过后的数据来模拟用户登录的动作也是可以的，所以纯粹对密码的加密其实不能解决这个问题，所以有了盐值，让同一个数据在不同情况下结果依旧不一致，但是盐值需要约定，总会被人找出规律，只是成本又高了点，所以还是不安全，这就引发了通讯安全的问题。
所以出现了https使用非对称加密来保护数据通路上的安全，让通讯变得不可窥视。


但是还有个东西叫木马，所以人们在输入上继续做文章，包括混淆输入，就是软键盘，好的控件不会把明文存在内存里，这很重要，以前的VB、Dephi密码控件都仅仅看不到，实际内存里面都是明文，很容易被病毒和木马利用，所以一般来说现在最安全的bs系统使用控件保护输入，隐藏自己的HASH算法，用HTTPS保护通讯。
但是ssl都有漏洞被爆出，所以好的系统加上用户自己勤换密码才是保护自己的不二法则，不过，太累了，所以使用硬件ukey吧，成本稍高。

2、@lam kin

浏览器打开页面时，服务器生成一个token，返回给客户端，客户端登录时，还是要加密，当然是包含该token来加密，然后返回给服务器，服务器解密验证，同时token失效以保证请求不会被replay登录，然后服务器生成session id返回给客户端，后面在浏览进程中以session id来判断用户。
客户端的加密，即使不可逆，如果每次加密后都是一样内容，那等于没加密，加入服务器提供的临时token来保证加密结果每次都不一样。
服务器接收到请求后，取用户注册时使用的密码密文跟临时token加密后进行比对。


临时token的生成，可以混入请求IP、时间戳、用户代理（userAgent）。


**各种专业名词的解释：**

1、replay攻击（重放攻击）攻击者发送一个目的主机已经接受过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认真的正确性。

2、证书 [http://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html ](http://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html )





以上。


